// utils
var Step = require('step');

// constants & globals
var REL_TYPE,
	TAG_REFERENCE,
	USER_REFERENCE,
	db;

var SearchRels = function(relType,database){
	db = database,
	REL_TYPE = relType;

	console.log('new search rels...' + REL_TYPE);

	db.query("START n = node(0) MATCH (n) <-[:USERS_REFERENCE]- (user_ref) RETURN user_ref", function(errors, nodes) {
		if (errors) {
			// TODO: throw errors
			console.log('Unable to locate a valid reference node for users');
			console.log(errors);
		} else {
			USER_REFERENCE = nodes[0]['user_ref'];
			// console.log(USER_REFERENCE);
		}
	});

	db.query("START n = node(0) MATCH (n) <-[:TAGS_REFERENCE]- (tag_ref) RETURN tag_ref", function(errors, nodes) {
		if (errors) {
			// TODO: throw errors
			console.log('Unable to locate a valid reference node for tags');
			console.log(errors);
		} else {
			TAG_REFERENCE = nodes[0]['tag_ref'];
			// console.log(TAG_REFERENCE);
		}
	});

	var prepQuery = function(type, direction, startID, callback){

		console.dir(arguments);

		var REL_AND_DIRECTION = (direction == 'out') ? ('-[rel?:' + REL_TYPE + ']->') : ('<-[rel?:' + REL_TYPE + ']-');
		var nodeDomainID;

		console.log(REL_AND_DIRECTION);

		switch(type) {
			case "tags":
				nodeDomainID = 1;
				break;
			case "users":
			default:
				nodeDomainID = 1;
				break;
		}

		var query = [
			'START domain_ref=node(DOMAIN_ID), start=node(START_ID), result',
			'MATCH (domain_ref) <-[:MEMBER_OF]- (result) REL_AND_DIRECTION (start)',
			'RETURN result, rel'
		].join('\n')
			.replace('DOMAIN_ID', nodeDomainID)
			.replace('START_ID', startID)
			.replace('REL_AND_DIRECTION', REL_AND_DIRECTION);

		callback(undefined, query);
	};

	return {
		tags: function(type, direction, startID, callback){
			Step(
				function getQueryString(){
					prepQuery(type, direction, startID, this);
				},
				function performQuery(err,query){
					console.dir(arguments);
					callback(undefined, query);
				}
			);
		}/*,
		users: function(callback){
			Step(
				function userSearches(){
					searchUsersExact( this.parallel() );
					searchUsersFull( this.parallel() );
				},
				function searchesComplete(err, exact, matching){
					var userResults = {
						type: "users"
					};

					if (exact.length) {
						userResults.exactMatch = {
							id: exact[0].id,
							title: exact[0]._data.data.username
						};
					}

					if (matching.length) {
						userResults.matching = [];
						for(var i=0, j=matching.length; i<j; i++) {
							if(userResults.exactMatch) {
								if (matching[i].id != userResults.exactMatch.id) {
									userResults.matching.push({
										id: matching[i].id,
										title: matching[i]._data.data.username
									});
								}
							} else {
								userResults.matching.push({
									id: matching[i].id,
									title: matching[i]._data.data.username
								});
							}
						}
					}
					callback(undefined,userResults);
				}
			);
		}*/
	};

};

module.exports = SearchRels;