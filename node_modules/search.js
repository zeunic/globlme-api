// utils
var Step = require('step');

// constants & globals
var QUERY_STRING,
	TAG_REFERENCE,
	USER_REFERENCE,
	db;

var Search = function(query, database){
	db = database,
	QUERY_STRING = query;

	db.query("START n = node(0) MATCH (n) <-[:USERS_REFERENCE]- (user_ref) RETURN user_ref", function(errors, nodes) {
		if (errors) {
			// TODO: throw errors
			console.log('Unable to locate a valid reference node for users');
			console.log(errors);
		} else {
			USER_REFERENCE = nodes[0]['user_ref'];
			// console.log(USER_REFERENCE);
		}
	});

	db.query("START n = node(0) MATCH (n) <-[:TAGS_REFERENCE]- (tag_ref) RETURN tag_ref", function(errors, nodes) {
		if (errors) {
			// TODO: throw errors
			console.log('Unable to locate a valid reference node for tags');
			console.log(errors);
		} else {
			TAG_REFERENCE = nodes[0]['tag_ref'];
			// console.log(TAG_REFERENCE);
		}
	});

	var searchTagsExact = function(callback){
		db.getIndexedNodes('tag', 'tag', QUERY_STRING , callback);
	};

	var searchTagsFull = function(callback){
		var wildCards = 'tag:' + QUERY_STRING + '*';
		db.queryNodeIndex('fulltext', wildCards , callback);
	};

	var searchUsersExact = function(callback){
		db.getIndexedNodes('user', 'username', QUERY_STRING , callback);
	};

	var searchUsersFull = function(callback){
		var wildCards = 'username:' + QUERY_STRING + '*';
		db.queryNodeIndex('fulltext', wildCards , callback);
	};

	return {
		tags: function(callback){
			Step(
				function tagSearches(){
					searchTagsExact( this.parallel() );
					searchTagsFull( this.parallel() );
				},
				function searchesComplete(err, exact, matching){
					var tagResults = {
						type: "tags"
					};

					if (exact.length) {
						tagResults.exactMatch = {
							id: exact[0].id,
							title: exact[0]._data.data.tag
						};
					}

					if (matching.length) {
						tagResults.matching = [];
						for(var i=0, j=matching.length; i<j; i++) {
							if(tagResults.exactMatch) {
								if (matching[i].id != tagResults.exactMatch.id) {
									tagResults.matching.push({
										id: matching[i].id,
										title: matching[i]._data.data.tag
									});
								}
							} else {
								tagResults.matching.push({
									id: matching[i].id,
									title: matching[i]._data.data.tag
								});
							}
						}
					}
					callback(undefined,tagResults);
				}
			);
		},
		users: function(callback){
			Step(
				function userSearches(){
					searchUsersExact( this.parallel() );
					searchUsersFull( this.parallel() );
				},
				function searchesComplete(err, exact, matching){
					var userResults = {
						type: "users"
					};

					if (exact.length) {
						userResults.exactMatch = {
							id: exact[0].id,
							title: exact[0]._data.data.username
						};
					}

					if (matching.length) {
						userResults.matching = [];
						for(var i=0, j=matching.length; i<j; i++) {
							if(userResults.exactMatch) {
								if (matching[i].id != userResults.exactMatch.id) {
									userResults.matching.push({
										id: matching[i].id,
										title: matching[i]._data.data.username
									});
								}
							} else {
								userResults.matching.push({
									id: matching[i].id,
									title: matching[i]._data.data.username
								});
							}
						}
					}
					callback(undefined,userResults);
				}
			);
		}
	};

};

module.exports = Search;